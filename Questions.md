

## Вопросы

### 1. Какой самый эффективный способ конкатенации строк?

Тип Builder из пакета strings или Buffer из пакета bytes

### 2. Что такое интерфейсы, как они применяются в Go?

Интерфейсы представляют абстракцию поведения других типов. Интерфейсы позволяют определять функции, которые не привязаны к конкретной реализации. То есть интерфейсы определяют некоторый функционал, но не реализуют его.  
В Go интерфейсы реализуются неявным образом. Конкретный тип не объявляет о том, что он реализует интерфейс. Если набор методов конкретного типа содержит все методы из набора методов интерфейса, то этот конкретный тип реализует интерфейс. Это означает, что этот конкретный тип может быть присвоен переменной или полю, в качестве типа которого указан данный интерфейс.

### 3. Чем отличаются RWMutex от Mutex?

Mutex блокирует как запись, так и чтение для других горутин. RWMutex только на запись

### 4. Чем отличаются буферизированные и не буферизированные каналы?

Небуферизованный канал блокируется после каждой записи в него, пока не будет выполнено чтение, и после каждого чтения, пока не будет выполнена запись. 
Буферизованный канал блокируется только когда буфер будет заполнен

### 5. Какой размер у структуры struct{}{}?

0 байт.

### 6. Есть ли в Go перегрузка методов или операторов?

нет

### 7. В какой последовательности будут выведены элементы map[int]int?

Пример:

```go
m[0]=1
m[1]=124
m[2]=281
```

В рандомной (в исходниках буквально стоит рандом). но при использовании fmt.Print(m) отображение будет выведено в порядке возрастания ключей

### 8. В чем разница make и new?

Make используется для создания срезов, карт и каналов, New для любых структур.  
Make возвращает значение создаваемого типа, New указатель. 
Make выделяет место в памяти и инициализирует внутреннюю структуру данных. New только выделяет место в памяти.

### 9. Сколько существует способов задать переменную типа slice или map?

Задать переменную типа среза или карты можно с помощью литералов этих структур и с помощью функции make().  
Можно присвоить значение среза и карты уже существующим переменным этого типа.

### 10. Что выведет данная программа и почему?

```go
func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}
```

Программа выведет:  
1  
1  
Потому что в функцию update передается копия указателя и изменяется значение копии указателя.

### 11. Что выведет данная программа и почему?

```go
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
```

Программа выведет сначала числа от 0 до 4 в произвольном порядке, затем fatal error: all goroutines are asleep - deadlock!

WaitGroup в главной горутине никогда не обнулится, потому что wg передается в функцию по значению (копия) и вызов метода Done не будет обнулять счетчик в главной горутине.
Чтобы это исправить, в функции горутин необходимо передавать указатель на WaitGroup.

### 12. Что выведет данная программа и почему?

```go
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
```

Программа выведет:  
0  
Потому что в блоке if создается переменная n, которая затеняет переменную n, вне блока if.

### 13. Что выведет данная программа и почему?

```go
func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}
```

Программа выведет:  
[100 2 3 4 5]  
  
В функцию передается копия структуры среза, в которой указатель на тот же массив, что и в исходном срезе, поэтому при изменение 0 индекса в копии среза, изменяется значении и в исходном срезе. 

Функция append вернет указатель на новую структуру среза, с новой длиной и емкостью, соответственно оригинал и копия среза теперь будут указывать на разные области в памяти, более того копия будет находиться в стековой памяти, которая перестанет существовать как только произойдет выход из функции.
Поэтому длина и емкость оригинального среза не изменятся.

### 14. Что выведет данная программа и почему?

```go
func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}
```

Программа выведет:  
[b b a][a a]


так же как в предыдущем случае вопросе, в пятой строчке создастся новая структура среза, и все изменения будут происходить уже с ней, что никак не повлияет на оригинальный срез